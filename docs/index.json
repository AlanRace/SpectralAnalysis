[{"uri":"/installation/","title":"Installation","tags":[],"description":"","content":"There are different ways to install SpectralAnalysis and you can choose the one that best fits your use case. The easiest method is to use the installer. If you already have MATLAB Runtime R2020a installed, then you can simply download the standalone version. Both of these work without requiring a MATLAB licence, however this cannot be modified or make use of any of the \u0026lsquo;advanced\u0026rsquo; functionality. The source code version requires a valid MATLAB licence, however can perform both general and advanced functionality.\nUsing the Installer  Download and run the latest installer. Run SpectralAnalysis.exe  Using the Standalone Version Currently requires 64-bit Windows. If you are running 32-bit Windows and want a standalone version please contact me.\n Download and extract the zip file of the latest release. Download and install the R2020a (9.8) MATLAB Runtime. Download and install the Visual C++ Redistributable for Visual Studio 2015. Run SpectralAnalysis.exe  Using the Source Code Version The source code version requires a valid MATLAB licence.\nInstallation with Git  Clone the repository.  git clone https://github.com/AlanRace/SpectralAnalysis Open MATLAB and navigate to the folder containing the source code. Run the command runSpectralAnalysis.  Installation without Git  Download the source code of the latest release. Open MATLAB and navigate to the folder containing the source code. Run the command runSpectralAnalysis.  Increase Java Heap Space Prior to running SpectralAnalysis, it is advisable to increase the \u0026lsquo;Java Heap Size\u0026rsquo; allocated to MATLAB to the maximum available. This enables larger imzML files to be opened successfully.\n MATLAB 2010a or later MATLAB 2009b or earlier  Compatible MATLAB Versions If you use a currently untested version of MATLAB, please let us know any successes or issues you encounter (submit issues).\n   MATLAB Version Compatibility Notes     R2014a or newer Compatible    R2013b or older Untested     "},{"uri":"/basic-usage/load-data/","title":"Load data","tags":[],"description":"","content":" Load Dataset (Open) Convert data to SpectralAnalysis format View memory usage interface Progress bar Log of activities that have been and are currently being performed  Load Dataset (Open) When selecting the \u0026lsquo;Open\u0026rsquo; menu, the list of currently implemented parsers (data types) will be shown, select the appropriate parser for the type of data to be opened.\nAfter selecting the file to open, the DataViewer interface will be shown. Futher details on the functionality of this interface can be found here. The parser (data type) determines the DataRepresentation (whether the data is to be loaded into memory for fast access, or whether the data is too large and will therefore be accessed on demand on disk) and default spectral preprocessing workflow automatically. The data can be reloaded with a different DataRepresentation in the Tools menu. The preprocessing workflow can be altered through the preprocessing editor.\n"},{"uri":"/basic-usage/load-data/parser/","title":"Parser","tags":[],"description":"","content":"A parser is something that understands a specific file format and enables the translation and loading of data.\n Advanced Currently supported parsers are\n ImzMLParser (Mass spectrometry imaging data, .imzML) SIMSParser (SIMS data, .tof or .grd)   To create a parser for a currently unsupported file type or style of data, extend the Parser class and add the new class into the same folder.\n"},{"uri":"/basic-usage/multivariate/pca/","title":"Principal Component Analysis (PCA)","tags":[],"description":"","content":"Principal component analysis (PCA) is a statistical technique that can be used for data exploration. It is not necessary to understand the details of PCA to be able to successfully use it to find patterns within your data, but they can help interpret how significant such a pattern is. The screenshot below shows SpectralAnalysis\u0026rsquo; interface for exploring PCA results.\nPerforming PCA There are two methods for performing PCA included within SpectralAnalysis. These can be found in the Data Reduction dropdown menu, as shown below.\nThe fastest method (PCA) requires the data to be in memory (see data representation), whereas Memory Efficient PCA only loads in the bare minimum amount of data at any one time and can therefore be performed on datasets much larger than the available RAM. See Race et al. (https://pubs.acs.org/doi/10.1021/ac302528v) for more details on this method.\nPCA Details The data is projected into a new space, such the the first dimension (principal component) captures the largest amount of variance within the data. Each subsequent principal component captures the largest amount of remaining variance, with the constraint that it must be orthogonal to all previous principal components.\n"},{"uri":"/tutorials/scripting-workflow/","title":"Scripting - datacube / kmeans","tags":[],"description":"","content":"This script was originally written by Adam Taylor, Teresa Murta and Alex Dexter and can be used to automatically generate a mean spectrum, detect peaks, reduce the data to the peaks with signal-to-noise greater than 3, perform k-means clustering (k = 2) on the reduced data, generate mean spectra for each cluster and then save out all variables.\nThis script demonstrates how SpectralAnalysis can be used without the interface to perform more complex and automatable analysis routines.\nspectralAnalysisPath = \u0026#39;C:\\path\\to\\SpectralAnalysis\u0026#39;; inputFolder = [spectralAnalysisPath filesep \u0026#39;example-data\u0026#39; filesep \u0026#39;mouse-brain\u0026#39;]; %location of imzML files to process outputFolder = [spectralAnalysisPath filesep \u0026#39;example-data\u0026#39; filesep \u0026#39;mouse-brain\u0026#39;]; filesToProcess = dir([inputFolder filesep \u0026#39;*.imzML\u0026#39;]); %gets all imzML files in folder % Set up datacube generation variables % Preprocessing file (.sap) location preprocessingWorkflowFile = [spectralAnalysisPath filesep \u0026#39;example-data\u0026#39; filesep \u0026#39;mouse-brain\u0026#39; filesep \u0026#39;mouse-brain-preprocessingWorkflow.sap\u0026#39;]; nzm_multiple = 3; % multiple of non zero median % Add SpectralAnalysis to the path - this only needs to be done once per MATLAB session disp(\u0026#39;Setting up \u0026#39;); addpath(genpath(spectralAnalysisPath)); addJARsToClassPath(); % Generate preprocessing workflow preprocessing = PreprocessingWorkflow(); preprocessing.loadWorkflow(preprocessingWorkflowFile); peakPicking = GradientPeakDetection(); medianPeakFilter = PeakThresholdFilterMedian(1, nzm_multiple); peakPicking.addPeakFilter(medianPeakFilter); %% for i = 1:length(filesToProcess) disp([\u0026#39;Processing \u0026#39; filesToProcess(i).name]); input_file = [filesToProcess(i).folder filesep filesToProcess(i).name]; % Get the filename from the path [~, filename, ~] = fileparts(input_file); %% make datacubes from each dataset % obtain total spectrum disp([\u0026#39;Generating Total Spectrum for \u0026#39; ,input_file]); parser = ImzMLParser(input_file); parser.parse; data = DataOnDisk(parser); spectrumGeneration = TotalSpectrum(); spectrumGeneration.setPreprocessingWorkflow(preprocessing); totalSpectrum = spectrumGeneration.process(data); totalSpectrum = totalSpectrum.get(1); %% Peak picking disp(\u0026#39;Peak picking \u0026#39;); peaks = peakPicking.process(totalSpectrum); spectralChannels_all = totalSpectrum.spectralChannels; spectralChannels = [peaks.centroid]; %% Make datacube disp([\u0026#39;! Generating data cube with \u0026#39; num2str(length(peaks)) \u0026#39; peaks...\u0026#39;]) % If peakTolerance \u0026lt; 0 then the detected peak width is used peakTolerance = -1; reduction = DatacubeReduction(peakTolerance); reduction.setPeakList(peaks); % Inform the user whether we are using fast methods for processing (i.e. Java methods) addlistener(reduction, \u0026#39;FastMethods\u0026#39;, @(src, canUseFastMethods)disp([\u0026#39;! Using fast Methods? \u0026#39; num2str(canUseFastMethods.bool)])); dataRepresentationList = reduction.process(data); % We only requested one data representation, the entire dataset so extract that from the list dataRepresentation = dataRepresentationList.get(1); % Convert class to struct so that if SpectralAnalysis changes the DataRepresentation class, the data can still be loaded in dataRepresentation_struct = dataRepresentation.saveobj(); datacube = dataRepresentation.data; pixels = dataRepresentation.pixels; %% K means clustering disp(\u0026#39;Performing k-means clustering on top 1000 peaks with k = 2 and cosine distance\u0026#39;) [~, top1000idx] = maxk([peaks.intensity], 1000); datacube_small = datacube(:,top1000idx); [kmeans_idx, kmeans_c, ~, ~ ] = kmeans(datacube_small, 2, \u0026#39;distance\u0026#39;, \u0026#39;cosine\u0026#39;); %% Make mean spectrum disp(\u0026#39;Saving cluster mean spectra\u0026#39;) datacube_clust1 = datacube(kmeans_idx == 1,:); datacube_clust2 = datacube(kmeans_idx == 2,:); mean_intensity_clust1 = mean(datacube_clust1); mean_intensity_clust2 = mean(datacube_clust2); mean_intensity_all = mean(datacube); %% Save all disp(\u0026#39;Saving files\u0026#39;) save([outputFolder filesep filename \u0026#39;.mat\u0026#39;], \u0026#39;-struct\u0026#39;, \u0026#39;dataRepresentation_struct\u0026#39;, \u0026#39;-v7.3\u0026#39;) save([outputFolder filesep filename \u0026#39;.mat\u0026#39;], ... \u0026#39;peaks\u0026#39;, \u0026#39;spectralChannels_all\u0026#39;, \u0026#39;spectralChannels\u0026#39;, \u0026#39;kmeans_idx\u0026#39;, \u0026#39;kmeans_c\u0026#39;, ... \u0026#39;top1000idx\u0026#39;, \u0026#39;mean_intensity_clust1\u0026#39;, \u0026#39;mean_intensity_clust2\u0026#39;, \u0026#39;mean_intensity_all\u0026#39;,... \u0026#39;-append\u0026#39;) disp([input_file \u0026#39; complete\u0026#39;]); end "},{"uri":"/basic-usage/visualisation/","title":"Data visualisation","tags":[],"description":"","content":"Feature List  View spectrum Generate image Customise image display Generate images from list Save image list Generate RGB composite View spectrum Overlay spectra  Interface Overview The interface has changed appearance in the latest version, but the information on this page is still accurate.\n  Generate a spectral representation Perform data reduction Perform clustering Image List panel Selected image display Region of Interest panel Spectrum List panel Selected spectrum display Spectral Preprocessing panel  View Spectrum To view the spectrum associated with a single pixel, simply click on the desired pixel and the spectrum will be displayed in the spectrum display panel.\n Zooming into a spectrum is performed by click-and-drag below the spectrum axis (see below) Zooming out is performed by double clicking below the spectrum axis  Image Generation This section is written to describe generation of images in mass spectrometry imaging (i.e. ion images, where the spectral channels are m/z values), but the same process applies for any spectral imaging data.\n Generation of ion images is performed by selecting one or more m/z limit pairs\nIon images that have been previously generated are marked by a tick (✓) in the \u0026lsquo;Generated\u0026rsquo; column in the Image List panel.\nWhen a dataset is loaded as \u0026lsquo;Data On Disk\u0026rsquo;, ion images are not automatically generated. As the generation of 10, 20, or even 100 ion images takes approximately the same amount of time when data is on disk, the generation process is only triggered when the user clicks the G button in the Image List panel. Once this button is clicked, all images that have not been previously generated (which do not have a tick (✓) next to them) in the image list will be generated.\n Various methods of generation ion images are discussed in the following sections.\nVisually select ion image limits Select the range by clicking and dragging above the axis in the spectrum.\nManually select ion image limits  Type the range manually into the Image List, with the minimum and maximum value separated by a hypen (-). Type a centroid value only into the Image List. When the images are generated, SpectralAnalysis will then automatically apply the range (+/-) with the units chosen (either PPM or Da) defined above the Image List.  Customise Image Display Right-clicking anywhere on the image will open the image context menu (shown below). Here you can set the colourmap to use, the pixel size or whether to display a scale bar.\nIf you set the scale bar to be displayed, but the pixel size information has not been captured, then SpectralAnalysis will request the pixel size of the image before displaying a scale bar.\n"},{"uri":"/basic-usage/","title":"General Use","tags":[],"description":"","content":"Feature List  Load spectral imaging data (mass spectrometry imaging, Raman) Visualise spectra and images (generate images, view spectra) Region of interest (generation and statistics) Spectral pre-processing Multivariate analysis (PCA, NMF, pLSA) Clustering Multimodality data analysis  Supported Data Formats  imzML the open mass spectrometry imaging format (.imzML) ION-TOF export (.grd or .tof) ASCII export from Raman spectroscopy (*.txt)  "},{"uri":"/advanced-use/","title":"Advanced Use","tags":[],"description":"","content":"SpectralAnalysis was designed in such a way to enable rapid development and integration of new algorithms (such as preprocessing, multivariate analysis or clustering methods). To facilitate this, it is possible to freely transfer data to a MATLAB workspace and back again. This provides MATLAB proficient users with the option of exporting their data to the workspace and visualisating and further processing in any way they desire.\nIntegration with MATLAB To take advantage of the transfer of data between the MATLAB workspace and SpectralAnalysis, the source code version of SpectralAnalysis must be used.\nExtracting data from the interface to MATLAB is then as simple as right clicking on the data that you want to export and selecting Export \u0026gt; To Workspace from the context menu.\nExtending SpectralAnalysis All functions can be extended within SpectralAnalysis. Examples on how to include new preprocessing and processing algorithms can be found in the examples/SkeletonClasses folder within the main SpectralAnalysis folder.\n"},{"uri":"/basic-usage/region-of-interest/","title":"Region of Interest","tags":[],"description":"","content":"Regions of interest (ROIs) are areas of an image, which can be used as input into subsequent data analysis. ROIs can be defined manually, as explained in this page, or automatically through processing such as clustering.\nFeature List  Generate ROI Calculate statistics on ROI Export ROIs  Overview The ROI panel can be found on the right on the main interface (number 1 in the image below).\n Region of interest list Save region of interest list Load region of interest list View statistics on ROI Add/edit/delete ROIs  Generate ROI To create an ROI manually, the Edit button on the main interface in the ROI panel must be clicked. This then opens the ROI List Editor, shown below, displaying the ion image which was previously active in the main interface.\nTo create a new ROI, first click the + button, and then in the new window, select an ROI name and colour and then click OK. This then adds the new ROI to the list (bottom left in the interface). The highlighted ROI is then displayed on top of the image, and any selected tool (defined below) can then be applied directly to the image by clicking and/or dragging.\n Pencil Assign individual pixels to the ROI. Line Assign all pixels which fall along a line drawn by the user to the ROI. Rectangle Assign all pixels which fall within a rectangle drawn by the user to the ROI. Ellipse Assign all pixels which fall within an ellipse drawn by the user. Poly Define an arbitrary shaped region of interest. Eraser Toggle button. When active, use any shape to define an area to remove from the current region of interest. When deactivated, areas are added to the ROI. Threshold Assign all pixels based on thresholds applied (see Threshold for more details). Move Allows dragging of the ROI to a new location.  Threshold When selecting the Threshold button, the following window will be shown, with the fields automatically poplated with the minimim and maximum intensity of the displayed ion image.\nCalculate statistics Once one or more regions of interest have been defined, it is possible to investigate the differences between these regions further.\nExport ROIs Selecting the \u0026lsquo;save\u0026rsquo; button in the ROI panel will bring up a dialog box for selecting an output location for the .rois file.\n"},{"uri":"/tutorials/","title":"Tutorials and example data","tags":[],"description":"","content":"Here you can find details on different ways of using SpectralAnalysis and freely available MSI data that can be used for testing.\nExample Data Mouse Brain (MALDI MSI QTOF) This mouse brain dataset is available alongside SpectralAnalysis. It was acquired using MALDI MSI with a QSTAR XL mass spectrometer.\nMouse Bladder (MALDI MSI Orbitrap) This mouse bladded dataset is available from the PRIDE repository. It was acquired using MALDI MSI with a AP-SMALDI imaging source coupled to an Orbitrap mass spectrometer.\n"},{"uri":"/tutorials/using-python/","title":"Using SpectralAnalysis in python","tags":[],"description":"","content":" Install MATLAB Install Python version 3.7 Install MATLAB Engine for Python  import matlab.engine print(\u0026#34;Starting MATLAB Engine. This may take a couple of seconds.\u0026#34;); eng = matlab.engine.start_matlab() print(\u0026#34;MATLAB Engine started.\u0026#34;) # Add SpectralAnalysis to MATLAB path eng.addpath(eng.genpath(r\u0026#34;C:\\\\Path\\\\To\\\\SpectralAnalysis\u0026#34;)) # Add Java libraries to MATLAB path eng.addJARsToClassPath(nargout=0) # Load in the example data using ImzMLParser mouseBrain = eng.ImzMLParser(r\u0026#34;C:\\\\Path\\\\To\\\\SpectralAnalysis\\\\example-data\\\\mouse-brain\\\\MouseBrainCerebellum.imzML\u0026#34;) eng.parse(mouseBrain, nargout=0) # Get the image parameters width = eng.getWidth(mouseBrain) height = eng.getHeight(mouseBrain) # Get the spectrum at position (1, 1) firstSpectrum = eng.getSpectrum(mouseBrain, 1, 1) # Get the spectralChannels array spectralChannels = eng.getfield(firstSpectrum, \u0026#39;spectralChannels\u0026#39;) spectralChannels = spectralChannels[0] intensities = eng.getfield(firstSpectrum, \u0026#39;intensities\u0026#39;) intensities = intensities[0] print(\u0026#34;Found spectrum with {0} values. First data point has spectral channel = {1} with intensity {2}\u0026#34;.format(len(spectralChannels), spectralChannels[0], intensities[0])) "},{"uri":"/roadmap/","title":"Development Roadmap","tags":[],"description":"","content":"Here you can find information on the future planning of SpectralAnalysis. This includes more long term projects. Smaller planned features can be found here.\nAssisted analysis SpectralAnalysis was developed with flexibiltiy in mind, and this has led to many features being included, but it is not always obvious which is most approriate for use with a certain type of data. Default processing workflows will be designed and implemented for common styles of data. These will however remain completely editable.\nHide experimental methods Optionally hide the parts of the software that are currently in development. This would provide a restricted view of only the key tools to make the selection of the correct tool easier. It should be possible to toggle this option as part of the interface.\nFree input/export of data Integration with additional software tools and programming languages by freely importing and exporting data in common formats.\nCalibration and alignment Re-calibration of spectra is important for the accurate assignment of peaks. This should be possible on a single spectrum basis and applicable to a whole dataset. Alignment between datasets is also important for larger studies, where instrument drift may affect the position of peaks.\nOptions file Keep track of user options (default colour map, experimental/normal view, etc.). This should be updated as the user changes options in the interface and retained for use when the user starts a new session.\n"},{"uri":"/basic-usage/ensure-consistent-mz-axis/","title":"Ensure consistent m/z axis","tags":[],"description":"","content":"Background A common method for reducing the size of the data without discarding information when saving mass spectrometry data is to only store data points where the intensity is greater than zero. This can result in the data points in any two spectra containing different m/z values (for example in one spectrum there may be a peak at 798.55 and therefore a corresponding data point, but in the next spectrum this peak was not detected and therefore this value is not present in the spectrum).\nThis method of storing spectra can cause issues for spectral visualisation, combining spectra (such as calculating an average, or generating a \u0026lsquo;data cube\u0026rsquo;) or performing preprocessing methods (such as smoothing or baseline correction).\n In the case of visualisation it is important that the zeros are replaced. In the case of combining spectra it is important that the spectra are consistent (i.e. that each spectrum has intensity values for exactly the same m/z values). In the case of preprocessing it is important that the m/z values are regularly distributed.  Applying a method in SpectralAnalysis  Select a spectrum by clicking on a pixel in the image. Open Preprocessing Workflow Editor by selecting Edit button in Spectral Preprocessing panel. Select most appropriate Zero Filling method (see Choosing the most appropriate method section below) and click the adjacent + button. Enter desired parameters for the chosen method (if appropriate, and applicable), optionally checking the effect of the zero filling method by zooming into the spectrum and observing the \u0026lsquo;before\u0026rsquo; and \u0026lsquo;after\u0026rsquo; spectra. Click OK to close the Edit Preprocesing Method window and then OK again to close the Preprocessing Workflow Editor. The chosen method(s) will now be automatically applied to any viewed spectrum.  Choosing the most appropriate method The most appropriate method to use depends on the data and the desired next step in the processing workflow. The methods included in SpectralAnalysis are described below.\n Combine Bins Fixed Point per Peak Interpolation Rebin Interpolation PPM Rebin Interpolation Rebin Orbitrap QSTAR PPM Rebin Rebin Calibration Synapt  Rebin Specify a m/z bin size, and a m/z range. The resulting m/z axis then spans the specified m/z range consisting of equally sized bins. All data points which fall within one of the bins are then added together to generate the resulting spectrum.\nPPM Rebin Specify a PPM bin size, and a m/z range. The resulting m/z axis then spans the specified m/z range consisting of bins of increasing size (each bin has a constant size in PPM, but as PPM is proportional to m/z, the bin size increases as m/z increases). All data points which fall within one of the bins are then added together to generate the resulting spectrum.\nInterpolation Rebin Specify a m/z bin size, and a m/z range. The resulting m/z axis then spans the specified m/z range consisting of equally sized bins. All data points are then interpolated onto the new m/z axis (linear interpolation).\nInterpolation PPM Rebin Specify a PPM bin size, and a m/z range. The resulting m/z axis then spans the specified m/z range consisting of bins of increasing size (each bin has a constant size in PPM, but as PPM is proportional to m/z, the bin size increases as m/z increases). All data points are then interpolated onto the new m/z axis (linear interpolation).\n   "},{"uri":"/basic-usage/preprocessing/","title":"Spectral Preprocessing","tags":[],"description":"","content":"Appropriate spectral preprocessing can have a significant impact on the subsequently visualised data and output from more advanced techniques such as multivariate anlaysis and machine learning. The most commonly used preprocessing method, but also most contentious, is normalisation.\n"},{"uri":"/basic-usage/spectral-representation/","title":"Spectral Representation","tags":[],"description":"","content":"A spectral representation is a spectrum which describes one or more pixels. Examples of spectral representations are:\n Mean spectrum Total spectrum Basepeak spectrum  These are useful as a means to get an overview of peaks present in the entire dataset or a specific region of interest. Spectral representations can be generated by selecting the Spectral Representation option in the menu bar (top of DataViewer window).\n Mean spectrum The mean spectrum contains the mean intensity at each spectral channel. Total spectrum The total spectrum contains the sum of all intensities at each spectral channel. Basepeak spectrum The basepeak spectrum contains the maximum intensity at each spectral channel.  "},{"uri":"/basic-usage/multivariate/","title":"Multivariate analysis","tags":[],"description":"","content":"Multivariate analysis covers a set of statistical methods for analysing data where each observation (in this case spectrum) has multiple variables (spectral channels, e.g. m/z) and the relationship between these is important. Various multivariate analysis methods are included within SpectralAnalysis, each with its own set of benefits and considerations.\nThe most commonly used method is principal component analysis (PCA).\n"},{"uri":"/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"/basic-usage/load-data/continuous-vs-profile/","title":"Continuous vs Profile","tags":[],"description":"","content":"The continuous and profile terminology are taken from imzML and are therefore primarily used in reference to mass spectrometry imaging data. Despite the nomenculature, continuous data does not necessarily mean that the data points are a continuum and profile data may be used to store peak picked data.\nContinuous data points are consistent for all spectra within the dataset. A single, global, array of spectral channels is stored once in the dataset. Each spectrum then simply stores the corresponding intensity array\nProfile data stored as [spectral channel, intensity] pairs per spectrum. Each spectrum can therefore have a different length.\n"},{"uri":"/basic-usage/load-data/data-representation/","title":"Data Representation","tags":[],"description":"","content":"A data representation is a means of accessing data. Currently two general data representations are implemented DataInMemory and DataOnDisk.\nDataInMemory data is loaded into memory on initialisation, resulting in faster processing of data at the cost of RAM.\nDataOnDisk only the metadata is loaded into memory, with data being accessed from the disk only when needed. This is slower than DataInMemory but allows processing of datasets much larger than the available RAM.\n Advanced To create a data representation for a currently unsupported style of data access, the DataRepresentation class should be extended and the new class added into the same folder.\n"},{"uri":"/basic-usage/preprocessing/normalisation/","title":"Normalisation","tags":[],"description":"","content":"Background The goal of normalisation is to scale the intensities of each pixel to remove systematic artefacts that affect intensity. For further reading on normalisation methods there are a number of articles that discuss this further\n Normalization in MALDI-TOF imaging datasets of proteins: practical considerations Robust data processing and normalization strategy for MALDI mass spectrometric imaging Exploring Ion Suppression in Mass Spectrometry Imaging of a Heterogeneous Tissue  Applying a method in SpectralAnalysis  Select a spectrum by clicking on a pixel in the image. Open Preprocessing Workflow Editor by selecting Edit button in Spectral Preprocessing panel. Select most appropriate Normalisation method (see Choosing the most appropriate method section below) and click the adjacent + button. Enter desired parameters for the chosen method (if appropriate, and applicable), optionally checking the effect of the zero filling method by zooming into the spectrum and observing the \u0026lsquo;before\u0026rsquo; and \u0026lsquo;after\u0026rsquo; spectra. Click OK to close the Edit Preprocesing Method window and then OK again to close the Preprocessing Workflow Editor. The chosen method(s) will now be automatically applied to any viewed spectrum.  Choosing the most appropriate method Choosing an appropriate normalisation method is challenging and depends on the artefacts that need to be removed. The methods included in SpectralAnalysis are described below.\n l2normalisation Median intensity normalisation Noise level normalisation p-norm normalisation Root mean square normalisation TIC normalisation  l2normalisation This method normalises the data such that the sum of the squares of each spectrum will always be add up to 1\nMedian intensity normalisation This normalises by dividing the intensities of each spectrum by the median intensity for that spectrum. In some datasets (particularly protein imaging) this is an estimation of the baseline of the data.\nNoise level normalisation This method aims to estimate the noise level in the dataset using the method described by Deininger et al. and normalises to this. This assumes that the noise in the data should be constant.\np-norm normalisation p-norm is a generalisable variation on the l2normalisation where the sum of the power p specified by the user adds up to 1. In the case where p = 2, this is equivalent to the l2norm, and p=1 is equivalent to the TIC norm\nRoot mean square normalisation Root mean square normalisation scales the intensities to the square root of the the arithmetic mean of the squares of the intensities for each spectrum.\nTIC normalisation This method scales the intensities of each spectrum such that they sum to 1. This method assumes that each spectrum should have the same total number of ion present.\n   "},{"uri":"/","title":"SpectralAnalysis","tags":[],"description":"","content":"SpectralAnalysis is analysis software for spectral imaging data, with a particular focus on mass spectrometry imaging data. SpectralAnalysis provides functionality for data visualisation, preprocessing, univariate statistics, multivariate analysis and machine learning.\n Download   Download the latest installer. This will install SpectralAnalysis and the necessary MATLAB Runtime for you.\n  Get the latest standalone version if you already have MATLAB Runtime R2020a installed.\n  Get the latest source code if you have MATLAB (any version) installed and want to transfer data between SpectralAnalysis and MATLAB.\n  \nGetting help If you are having issues or have questions related to SpectralAnalysis you can write to us on the SpectralAnalysis Google Group or email us.\nCiting SpectralAnalysis If you find this software useful in your research please cite:\n Alan M. Race, Andrew D. Palmer, Alex Dexter, Rory T. Steven, Iain B. Styles, and Josephine Bunch, Anal. Chem., 2016, 88 (19), pp 9451–9458. http://dx.doi.org/10.1021/acs.analchem.6b01643\n Contributing to SpectralAnalysis We welcome all contributions to make SpectralAnalysis better. If you would like to contribute to SpectralAnalysis, please first read our code of conduct and then see the contributing guide.\nAcknowledgements Logo made by the very talented Buffy Randall.\n"},{"uri":"/tags/","title":"Tags","tags":[],"description":"","content":""}]